- Karatsura: multiplicar inteiros

 5678 x 1234
 a b  x c d

 a = 56
 b = 78
 c = 12
 d = 34

 5678 x 1234 = ( a*10^(n/2) + b) * ( c*10^(n/2) + d)
             = ac*10^n + ad*10^(n/2) + bc*10(n/2) + bd
             = ac*10^n + (ad + bc)*10^(n/2) + bd

 (ad + bc) = (a+b)*(c+d) - a*c - b*d

Calcular
1) a*c
2) b*d
3) (a+b)*(c+d)
4) (ad + bc) = (3) - (1) - (2)

Resposta: (1)*10^n + (4)*10^n/2 + (2)

Conclusão: com esse algoritmo faremos 3 multiplicações de (n/2) digitos

=====================================================

- Merge sort: dividir para conquistar algoritmo - 6nlog(2)n + 6n - very flat quickly

 log(2): #d times you divide by 2 until you get 1

 Proof of claim: At each level j=0,1,2,..., log(2)n, there are 2^j subproblems, each of size n/(2^j)
	Merger <= 6M

 <= 2^j (# of level-j subproblems) x 6 (n/(2^j)) (subproblem size at level j) = 6n (independent of j !!!) 

Total <= 6n *work per level) x (log(2)n + 1) (# of levels) = 6nlog(2)n + 6n

Identity function: f(n) = n
Quadratic function: f(n) = n^2

Outros piores que o Merge Sort:
Selection Sort: n² (quadratic function)
Insertion Sort: 1/2 x n²
Bubble Sort: n²

- Asymptotic analysis: focus on running time for large input sizes n

fast algorithm == worst-case running time grows slowly with input size

T(n) = O(f(n)) <= Cf(n), for a C and n >= n0

Claim: if T(n) = a(k)n^k + ... + a(1)n + a0 then T(n) = O(n^k)
Proof: Choose n0 = 1 and c= |a(k)| + |a(k-1)| + ... + |a1|
Need to show than qualquer n>=1, T(n) <= cn^k
we have, for every n>=1,
T(n) <= |a(k)|n^k + ... + |a(1)|n + |a(0)|
T(n) <= |a(k)|n^k + ... + |a(1)|n^k + |a(0)|n^k
T(n) <= cn^k

O (O Big Notation) = less than or equal to (upper bound)
Mega (Big omega notation) = greater than or equal to (lower bound)
Theta (Big theta notation) = equal to

==========
Counting Inversions = # A[i] > A[j], where i<j

1, 2, 3, 4, 5, 6 = zero inversions

6, 5, 4, 3, 2, 1 = 15 inversions => n(n-1)/2

O(n) = n log n

==========
Strassen's Subcubic Matrix Multiplication Algorithm

O(n) = n^3
O(n) = n^2 (strassen)

==========
algorithm for closest pair problem

O(n) = n log n

============
Recurrence Format: Master Method or Master Theorem

1) Base case: T(n) <= a constant for all sufficiently small n.
2) For all large n: T(n) <= aT(n/b) + O(n^d)

	a = number of recursive calls (>=1)
	b = input size shrinkage factor (>1)
	d = exponent in running time of "Combine step" (>=0)

	[a,b,d independent of n]

Master Method

	1) O(n^d * log n) if a = b^d (case 1) todos os levels tem o mesmo trabalho
T(n) =	2) O(n^d)         if a < b^d (case 2) a cada level o trabalho diminui, quase todo o trabalho está na raíz
	3) O(n^log(b)a)   if a > b^d (case 3) == O(a^log(b)n) a cada level o trabalho aumenta, quase todo o trabalho está nas folhas (a^log(b)n) # de folhas

======================
QuickSort

O(n) = n log n (average - with random pivots)


Minimum #levels: Θ(log(n))
Maximum #levels: Θ(n)

The best case is when the algorithm always picks the median as a pivot, in which case the recursion is essentially identical to that in MergeSort. In the worst case the min or the max is always chosen as the pivot, resulting in linear depth.

========================
Randomized Selection

RSelect(Array A, length n, order statistics i) 

Running time of RSelect <= 8 * c * n

O(n) = n

=========================
Graphs and Minimum Cuts

Graphs:
- Vertices: aka nodes (v) [vertex]
- Edges: pairs of vertices (E)
    - Can be undirected (unordered pair)
    - or directed (ordered pair) - aka arcs (arrows)

Cuts of Graphs:
- Definition: a cut of a graph (V,E) is a partition of V into two non-empty sets A and B.

- Definition: the crossing edges of a cut (A,B) are those with:
    - one endpoint in each of (A, B) [undirected]
    - tail in A, head in B [directed]

The Minimum Cut Problem:
- Input: an undirected graph G = (V,E)
- Goal: compute a cut with fewest number of crossing edges (a min cut). Parallel edges allowed.

A Few Applications:
- identify network bottlenecks / weaknesses
- community detection in social networks
- image segmentation

n vertices => minimum #edges = n -1 and maximum #edges = n * (n - 1) / 2

Sparse X Dense Graphs

n = # of vertices
m = # of edges

==========================
The Adjacency Matrix

Vertices = 1, 2, 3, 4, ...
A = n x n where Aij = 1 => Graph has an i-j edge

Variants:
- Aij = # of i-j edges (if parallel edges)
- Aij = weight of i-j edge (if any)
- Aij = +1 if i->j or -1 if i<-j

==============================
Random Contraction Algorithm

P = 2 / (n*(n-1)) >= 1 / n^2 de escolher um edge cujo um dos vertices está no grupo A e o outro no grupo B.

probability fail = 1 - 1/(n^2)

Repeat N trials

Probabilty[all N trials fail] <= (1 - 1/n^2)^N

1 + x <= e^x

Pr[all N trial fail] <= (e^(-1/n^2))^N

So: if N=n^2, Pr[all fail] <= (e^(-1/n^2))^(n^2) = 1/e
    if N=n^2 * ln(n), Pr[all fail] <= (1/e)^ln n = 1/n

Running time: polynomial in n and m but slow (r(n²*m))
But: can get big speedups [to roughly O(n²)] with more ideas.

# of minimum cuts 

[a tree with n vertices has (n - 1) minimum cuts]

Question: what's the largest number of min cuts that a graph with n vertices can have?
Answer: (n 2) = (n * (n - 1)) / 2

Pr[output = (Ai,Bi)] >= (2 / n * (n -1)) = 1 / (n 2)

========================================
Graph Search

Breadth-First Search - BFS
- O(m + n) time using a queue (FIFO)
- explore nodes in "layers"
- can compute shortest paths
- can compute connected components of an undirected graph.

Depth-First Search - DFS
- O(m + n) time using a stack (LIFO) or via recursion
- explore aggressively like a maze, backtrack only when necessary.
- compute topological ordering of directed acyclic graph
- compute connected components in directed graphs

connected componentes = the "pieces" of graph. Equivalence classes of relation u~v <=> E u-v path in G

topologic ordering
- sequence tasks while respecting all precedence constraints.
- G has directed cycle => no topological ordering.
- every directed acycle graph has a sink vertex.

strongly connected components - SCC
- SCC of a directed graph G are the equivalence classes of the relation
u~v <=> E path u -> v and E path v -> u in G
- kosaraju's Two-Pass Algorithm:
 1) Let Grev = G with all arcs reversed
 2) run DFS-Loop on Grev (goal: compute "magical ordering" of nodes) - let f(v)="finishing time" of each v e V.
 3) run DFS-Loop on G (goal: discover the SSCs one-by-one) - proceeding nodes in decreasing order of finishing times - SSCs = nodes with the same "leader"

Web Graph:
- vertices = web pages
- directed edges = hyperlinks
- Reference: [Broder et al www 2000]
- Recommended reading: Easley + Kleinberg, "Networks, Crowds, Markets"

